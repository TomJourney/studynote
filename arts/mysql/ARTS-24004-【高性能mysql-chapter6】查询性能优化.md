# 【高性能mysql-6】mysql性能优化

【readme】 本文总结自《高性能mysql》第6章；  

## 【6.1】为什么查询速度这么慢

1. 编写快速的查询sql之前，**主要关注的是响应时间**；
   1. 查询看做一个任务 ，它有多个子任务组成；
   2. 若要优化查询性能，或者优化单个子任务，或者减少子任务个数，或者减少子任务执行次数，或者两者一起优化；
2. 查询执行顺序如下：
   1. 客户端；
   2. 服务器；
      1. 解析
      2. 生成执行计划；
      3. 执行（最重要阶段，包括了大量为了检索数据到存储引擎的调用，以及调用后的处理，如排序与分组）；
      4. 返回结果；
3. 查询需要的时间花费：
   1. **包括网络，cpu计算，生成统计信息和执行计划，锁等待（互斥等待）等操作**； 
   2. 尤其是向存储引擎的调用操作，这些调用需要在内存，**cpu操作和内存不足时导致的IO操作，如文件排序**；
   3. 根据存储引擎不同，可能会产生大量的上下文切换及系统调用； 
4. 优化查询的目的：就是为了减少和消除这些操作所花费的时间； 



## 【6.2】慢查询基础：优化数据访问 

1. 查询性能低下最基本的原因： 访问的数据太多；

2. 对于低效查询，通过如下两个步骤来分析很有效；
   1. 步骤1：确认应用程序如jdbc客户端是否在检索大量超过需要的数据；（**可能访问了太多行或太多列**）
   2. 步骤2：确认mysql服务器层是否在分析大量超过需要的数据行；

### 【6.2.1】第1步：是否向数据库请求了不需要的数据

1. 典型案例：
   1. 查询不需要的记录； 
   2. 总是取出全部列（使用select *）； 
      1. 取出全部列，会让优化器无法完成 索引覆盖扫描这类优化，为服务器带来额外的IO，内存和cpu的消耗； 
      2. 取出全部列，也不总是坏事，如可以增加sql复用，构建缓存等；但应该要清楚查询所有列的缺点，合理选择；
   3.  重复查询相同的数据；如用户头像或名字（这其实利用缓存来解决）



### 【6.2.2】第2步：mysql是否在扫描额外的记录

1. 最简单地衡量查询开销的3个指标（这3个指标都会记录到mysql的**慢日志**中）：
   1. 响应时间； 
   2. 扫描行数； 
   3. 返回行数；  

#### 响应时间

1. 响应时间=服务时间+排队时间；
   1. 服务时间：数据库处理这个查询真正花费的时间；
   2. 排队时间：服务器因为等待某些资源而没有执行查询的时间；如等待IO操作，锁等待；



#### 扫描行数与返回行数

理想情况下，扫描行数与返回行数应该是相同的； 但实际上并不是； 

如在做关联查询时， 服务器必须要扫描多行才能生成结果集中的一行；



##### 扫描行数和访问类型

explain查询执行计划的结果中，**type列反应了访问类型； 

![image-20240406204249742](.//image//image-20240406204249742.png)

【说明】using where： 表明mysql将通过 where条件筛选存储引擎返回的记录；  

1. **访问类型-type列（速度从慢到快，扫描行数从大到小）**：
   1. all：全表扫描；
   2. index：全索引扫描；
   3. range：范围扫描；
   4. ref： 使用非唯一索引或唯一索引前缀扫描，返回某个单独值的记录行； 
   5. eq_ref： 使用唯一索引扫描，如主键或唯一键；
   6. const/system： 常量查询； 
      1. system是const的特例，当查询的表只有一行时使用system； 
2. <font color=red>mysql使用如下3种方式应用where条件（从好到坏）：</font>
   1. 索引中使用 where 过滤不匹配的记录；（在存储引擎层完成）； 
   2. 使用索引覆盖扫描（extra列中出现using index）返回记录；直接从索引中过滤不需要的记录并返回命中结果； （这是在mysql服务器完成的，但无需再回表查询）； 
   3. 从数据库表中反馈数据，然后过滤不满足条件的记录（extra列出现using where）；这是在mysql服务器完成，mysql先从数据库表读出记录然后过滤；  
3. 若查询语句的扫描行数大于结果行数，可以使用的优化策略如下：
   1. 使用索引覆盖扫描； 把所有列都放入索引，无需回表；
   2. 改变库表结果； 如单独的汇总表；
   3. 重写这个复杂的查询sql，让mysql优化器能够以更优的方式执行这个查询； 



## 【6.3】重构查询的方式

### 【6.3.1】一个复杂查询还是多个简单查询

设计查询时要考虑一个重要问题： 是否需要将一个复杂查询分成多个简单子查询； 

### 【6.3.2】切分查询

分治思想；

如删除历史数据；并不是一次性删除所有历史数据，而是采用小批量删除，如每次删除1万，或500条数据； 

### 【6.3.3】分解关联查询

1. 简单说：把一个连表查询拆分为多个单表查询，然后在应用程序如java内存中做关联；  
2. 优势；
   1. 让缓存的效率更高； 
   2. 单个查询可以减少锁竞争；
   3. 可以在应用中执行哈希关联（连表），而不是使用mysql的嵌套循环关联；某些场景哈希关联的效率要高很多；  
   4. 查询本身效率也可以提升； （如使用in子句代替关联查询，可以让mysql按照id顺序进行查询，这比随机的关联要更高效）
   5. 可以减少冗余记录的查询； 

## 【6.4】查询执行的基础























































